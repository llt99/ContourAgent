<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ContourAgent Quick Test - OpenLayers</title>

    <!-- OpenLayers CSS and JS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.3.0/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@v7.3.0/dist/ol.js"></script>
    <!-- SheetJS for Excel parsing -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <style>
        /* åœ°å›¾å®¹å™¨æ ·å¼ */
        #map {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .map-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(240, 242, 245, 0.9);
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 14px;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: #f5f5f5;
        }

        .page {
            width: 100%;
            display: flex;
            height: 95vh;
            gap: 12px;
            padding: 12px;
            box-sizing: border-box;
        }

        .qa-card {
            flex: 1;
            max-width: 33%;
            background: #fff;
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .map-card {
            flex: 2;
            position: relative;
            background: #f0f2f5;
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header-with-history {
            display: flex;
            align-items: center;
            position: relative;
            margin-bottom: 12px;
        }

        .title {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #333;
            margin: 0;
        }

        .history-btn {
            padding: 6px 10px;
            border-radius: 50%;
            background: #f0f0f0;
            border: none;
            cursor: pointer;
            z-index: 101;
        }

        .chat-box {
            position: relative;
            display: flex;
            height: calc(100vh - 4rem);
            flex: 1;
            overflow-y: auto;
            background: #fdfdfd;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 10px;
            margin-bottom: 12px;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 2px;
            max-height: 100%;
        }

        .msg {
            display: flex;
            margin-bottom: 8px;
            word-break: break-word;
            padding: 6px 12px;
            border-radius: 10px;
        }

        /* assistantï¼šå¤´åƒåœ¨å·¦ï¼Œå†…å®¹åœ¨å³ */
        .msg.assistant {
            justify-content: flex-start;
            flex-direction: row;
        }

        /* userï¼šå†…å®¹åœ¨å·¦ï¼Œå¤´åƒåœ¨å³ */
        .msg.user {
            align-self: flex-end;
            flex-direction: row-reverse;
            justify-content: flex-start;
            //text-align: right;
        }

        /* å¤´åƒç»Ÿä¸€æ ·å¼ */
        .role-label {
            font-size: 20px;
            line-height: 1;
            margin: 0 6px;
        }


        .text {
            display:inline-block;
            background:#e0f0ff;
            padding:8px 12px;
            border-radius:10px;
            max-width:80%;
            white-space:pre-wrap;
            word-wrap:break-word;
        }

        .input-area {
            display:flex;
            gap:10px;
        }

        input[type="text"] {
            flex:1;
            padding:10px;
            border-radius:10px;
            border:1px solid #ccc;
            font-size:14px;
        }

        button {
            padding:10px 16px;
            background:#007bff;
            color:#fff;
            border:none;
            border-radius:10px;
            cursor:pointer;
            font-size:14px;
        }

        button:hover {
            background:#0056b3;
        }

        .chat-image img {
            max-width: 200px;
            max-height: 150px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 4px;
        }

        .history-panel {
            position: absolute;
            top: 0;
            width: 280px;
            background: #fff;
            border-radius: 0 12px 12px 0;
            box-shadow: 0 2px 12px rgba(0,0,0,0.15);
            padding: 12px;
            z-index: 100;
            overflow-y: auto;
        }

        .legend-card-vertical {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            padding: 20px;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .map-download-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1001;
            background: #cecece;
            color: #fff;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .preview-overlay {
            position:fixed;
            top:0;
            left:0;
            right:0;
            bottom:0;
            background:rgba(0,0,0,0.8);
            display:flex;
            align-items:center;
            justify-content:center;
            z-index:9999;
        }

        .preview-img {
            max-width:90%;
            max-height:90%;
            border-radius:8px;
        }

        .circle-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #007bff;
            color: white;
            border: none;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .circle-btn:hover {
            background: #0056b3;
        }

        /* æµ‹è¯•æç¤º */
        .test-hint {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 8px;
            font-size: 12px;
            color: #856404;
        }

        .test-hint strong {
            color: #856404;
        }

        .test-status {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 6px;
            padding: 6px 10px;
            margin: 4px 0;
            font-size: 11px;
            color: #155724;
            font-weight: bold;
        }

        .test-status.error {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        .test-status.loading {
            background: #fff3cd;
            border-color: #ffeaa7;
            color: #856404;
        }
    </style>
</head>
<body>
<div class="page">
    <div class="qa-card">
        <div class="header-with-history">
            <button class="history-btn" onclick="toggleHistory()">ğŸ“œ</button>
            <h2 class="title">GeoContour AI</h2>
        </div>

        <!-- æµ‹è¯•æç¤º -->
        <div class="test-hint">
            <strong>ğŸ’¡ Test Hint:</strong> Enter a mapping task below, for example: â€œDraw the coal rock distribution map of the Longtan Formation in the Sichuan Basin.â€"
        </div>

        <!-- æµ‹è¯•çŠ¶æ€æ˜¾ç¤º -->
        <div id="testStatus" style="display: none;"></div>

        <div class="chat-box" ref="chatBox">
            <div v-if="showHistory" class="history-panel" style="display: none;">
                <h4 class="font-bold mb-4">History</h4>
                <ul id="historyList">
                    <!-- åŠ¨æ€ç”Ÿæˆå†å²è®°å½• -->
                </ul>
            </div>

            <div class="messages" id="chatMessages">
                <div class="msg assistant">
                    <span class="role-label">ğŸ¤–</span>
                    <div class="text">Hello, I am the Geological Contour Map Intelligent Assistant. Please describe your mapping request, for example: "Draw the coal rock distribution map of the Longtan Formation in the Sichuan Basin."</div>
                </div>
            </div>
        </div>

        <div class="input-area">
            <input type="file" id="fileInput" accept=".xlsx, .xls" style="display: none" onchange="handleFileUpload(event)"/>
            <button class="circle-btn" onclick="document.getElementById('fileInput').click()" title="ä¸Šä¼ Excelæ–‡ä»¶">+</button>
            <input type="text" id="userInput" placeholder="Please enter your mapping request..." onkeypress="if(event.key==='Enter') sendMessage()"/>
            <button onclick="sendMessage()">Send</button>
        </div>
    </div>

    <div class="map-card" id="mapContainer">
        <div id="map"></div>
        <div class="map-overlay" id="mapOverlay">
            <div>ğŸ—ºï¸ åœ°å›¾åŠ è½½ä¸­...<br><small>ç­‰å¾…ç”Ÿæˆç­‰å€¼çº¿å›¾</small></div>
        </div>
        <button class="map-download-btn" onclick="downloadMap()">â¬‡ ADD MAP</button>
<!--        <div class="legend-card-vertical" id="legendCard" style="display: none;">-->
<!--            <div class="legend-title">Legend</div>-->
<!--            <div class="legend-content" id="legendContent"></div>-->
<!--        </div>-->
    </div>
</div>

<script>
    // å…¨å±€å˜é‡

    // import ol from "ol/dist/ol.js";

    const API_BASE = 'http://127.0.0.1:8000';
    let currentImage = null;
    let showHistory = false;
    let historyList = [];
    let map = null;
    let offlineLayer = null;

    // åˆå§‹åŒ–ç¦»çº¿åœ°å›¾ï¼ˆä½¿ç”¨OpenLayersï¼‰
    function initOfflineMap() {
        console.log('ğŸ” æ£€æŸ¥OpenLayersåº“:', typeof ol);
        console.log('ğŸ” æ£€æŸ¥åœ°å›¾å®¹å™¨:', document.getElementById('map'));

        const mapContainer = document.getElementById('map');
        if (!mapContainer) {
            console.error('âŒ åœ°å›¾å®¹å™¨ä¸å­˜åœ¨');
            return;
        }

        if (map) {
            console.log('âš ï¸ åœ°å›¾å·²å­˜åœ¨ï¼Œè·³è¿‡åˆå§‹åŒ–');
            return;
        }

        console.log('å¼€å§‹åˆå§‹åŒ–OpenLayersåœ°å›¾...');

        try {
            // æ£€æŸ¥OpenLayersæ˜¯å¦åŠ è½½
            if (typeof ol === 'undefined') {
                throw new Error('OpenLayersåº“æœªåŠ è½½ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
            }

            // åˆ›å»ºç¦»çº¿ç“¦ç‰‡å›¾å±‚
            const tileLayer = new ol.layer.Tile({
                source: new ol.source.XYZ({
                    url: '/public/tiles/{z}/{x}/{y}.png'
                })
            });

            map = new ol.Map({
                target: 'map',
                layers: [tileLayer],
                view: new ol.View({
                    projection: 'EPSG:3857',
                    center: ol.proj.fromLonLat([106.5, 30.35]),
                    zoom: 7.8
                })
            });


            console.log('âœ… OpenLayersåœ°å›¾åˆ›å»ºæˆåŠŸ');

            // ç›‘å¬åœ°å›¾åŠ è½½äº‹ä»¶
            map.on('loadstart', function() {
                console.log('ğŸ”„ åœ°å›¾å¼€å§‹åŠ è½½...');
            });

            map.on('loadend', function() {
                console.log('âœ… åœ°å›¾åŠ è½½å®Œæˆ');
                const overlay = document.getElementById('mapOverlay');
                if (overlay) {
                    overlay.style.display = 'none';
                }
            });

            // ç›‘å¬ç“¦ç‰‡åŠ è½½é”™è¯¯
            tileLayer.getSource().on('tileloaderror', function(event) {
                console.warn('âš ï¸ ç“¦ç‰‡åŠ è½½å¤±è´¥:', event.tile.getImage().src);
            });

            // ç›‘å¬ç“¦ç‰‡åŠ è½½æˆåŠŸ
            tileLayer.getSource().on('tileloadend', function(event) {
                console.log('âœ… ç“¦ç‰‡åŠ è½½æˆåŠŸ:', event.tile.getImage().src);
            });

            // æµ‹è¯•ä¸€ä¸ªå…·ä½“çš„ç“¦ç‰‡URL
            const testUrl = '/tiles/10/800/407.png';
            console.log('æµ‹è¯•ç“¦ç‰‡URL:', testUrl);

            // å°è¯•é¢„åŠ è½½ä¸€ä¸ªç“¦ç‰‡æ¥éªŒè¯è·¯å¾„
            fetch(testUrl, { method: 'HEAD' })
                .then(response => {
                    console.log('æµ‹è¯•ç“¦ç‰‡å“åº”çŠ¶æ€:', response.status);
                    if (response.ok) {
                        console.log('âœ… ç“¦ç‰‡æ–‡ä»¶å¯è®¿é—®');
                    } else {
                        console.warn('âŒ ç“¦ç‰‡æ–‡ä»¶ä¸å¯è®¿é—®ï¼ŒçŠ¶æ€:', response.status);
                    }
                })
                .catch(err => {
                    console.error('âŒ ç“¦ç‰‡æ–‡ä»¶è®¿é—®å¤±è´¥:', err);
                });

            // æ˜¾ç¤ºåœ°å›¾å®¹å™¨
            mapContainer.style.display = 'block';
            console.log('âœ… ç¦»çº¿åœ°å›¾å·²åˆå§‹åŒ–å®Œæˆ');

        } catch (error) {
            console.error('âŒ åœ°å›¾åˆå§‹åŒ–å¤±è´¥:', error);
            console.error('é”™è¯¯è¯¦æƒ…:', error.message, error.stack);
            // å¦‚æœåˆå§‹åŒ–å¤±è´¥ï¼Œæ˜¾ç¤ºæç¤ºä¿¡æ¯
            const overlay = document.getElementById('mapOverlay');
            if (overlay) {
                overlay.innerHTML = `<div>âš ï¸ åœ°å›¾åˆå§‹åŒ–å¤±è´¥<br><small>${error.message}</small></div>`;
                overlay.style.display = 'flex';
            }
        }
    }

    // åœ¨åœ°å›¾ä¸Šæ˜¾ç¤ºGeoJSONç­‰å€¼çº¿
    function displayGeoJSONOnMap(geojson, dataRows = []) {
        if (!map || !geojson) {
            console.warn('âŒ åœ°å›¾æˆ–GeoJSONæ•°æ®ä¸ºç©º', { map: !!map, geojson: !!geojson });
            return false;
        }

        console.log('ğŸ”„ å¼€å§‹æ¸²æŸ“GeoJSON(åŸå§‹è¾“å…¥):', geojson);

        // âœ… 1) å…¼å®¹åç«¯è¿”å›å¤–å£³ï¼š{ map: FeatureCollection }
        if (geojson && !geojson.type && geojson.map && geojson.map.type) {
            console.warn('âš ï¸ GeoJSON å¤–å±‚åŒ…å« mapï¼Œå·²è‡ªåŠ¨è§£åŒ…åˆ° geojson.map');
            geojson = geojson.map;
        }

        // âœ… 2) å…¼å®¹å­—ç¬¦ä¸²
        if (typeof geojson === 'string') {
            try {
                geojson = JSON.parse(geojson);
                console.warn('âš ï¸ GeoJSON ä¸ºå­—ç¬¦ä¸²ï¼Œå·²è‡ªåŠ¨ JSON.parse');
            } catch (e) {
                console.error('âŒ GeoJSONå­—ç¬¦ä¸²è§£æå¤±è´¥:', e, geojson);
                return false;
            }
        }

        // âœ… 3) ä¸¥æ ¼æ ¡éªŒ
        if (!geojson || typeof geojson !== 'object') {
            console.error('âŒ GeoJSONä¸æ˜¯å¯¹è±¡:', typeof geojson, geojson);
            return false;
        }
        if (!geojson.type) {
            console.error('âŒ GeoJSONç¼ºå°‘typeå±æ€§:', geojson);
            return false;
        }
        if (!geojson.features || !Array.isArray(geojson.features)) {
            console.error('âŒ GeoJSONç¼ºå°‘featuresæˆ–featuresä¸æ˜¯æ•°ç»„:', geojson);
            return false;
        }

        console.log('âœ… æœ€ç»ˆç”¨äºæ¸²æŸ“çš„ GeoJSON.type =', geojson.type, 'features:', geojson.features.length);

        // âœ… 4) æ¸…é™¤ç°æœ‰å›¾å±‚ï¼ˆä¿ç•™åº•å›¾ç“¦ç‰‡å›¾å±‚ index=0ï¼‰
        const layers = map.getLayers().getArray();
        for (let i = layers.length - 1; i > 0; i--) {
            map.removeLayer(layers[i]);
        }

        // âœ… å·¥å…·ï¼š#RRGGBB -> rgba
        function hexToRgba(hex, alpha = 0.8) {
            if (!hex || typeof hex !== 'string') return `rgba(255,0,0,${alpha})`;
            if (hex.startsWith('rgb')) return hex;

            const h = hex.replace('#', '');
            const full = h.length === 3 ? h.split('').map(c => c + c).join('') : h;
            if (full.length !== 6) return `rgba(255,0,0,${alpha})`;

            const r = parseInt(full.slice(0, 2), 16);
            const g = parseInt(full.slice(2, 4), 16);
            const b = parseInt(full.slice(4, 6), 16);
            if ([r, g, b].some(Number.isNaN)) return `rgba(255,0,0,${alpha})`;

            return `rgba(${r},${g},${b},${alpha})`;
        }

        try {
            // âœ… 5) è¯»å– GeoJSON é¢è¦ç´ ï¼ˆEPSG:4326 -> EPSG:3857ï¼‰
            const polygonFeatures = new ol.format.GeoJSON().readFeatures(geojson, {
                featureProjection: 'EPSG:3857',
                dataProjection: 'EPSG:4326'
            });

            const polygonSource = new ol.source.Vector({ features: polygonFeatures });
            console.log('âœ… é¢è¦ç´ è¯»å–æˆåŠŸ:', polygonFeatures.length);

            // âœ… 6) ä» dataRows æ„å»ºäº•ç‚¹è¦ç´ ï¼ˆæ³¨æ„ï¼šæ‰‹åŠ¨åˆ›å»ºç‚¹è¦è‡ªå·±æŠ•å½±è½¬æ¢ï¼‰
            const pointFeatures = [];
            if (Array.isArray(dataRows) && dataRows.length > 0) {
                for (const r of dataRows) {
                    if (!r) continue;
                    if (r.lon == null || r.lat == null) continue;

                    const lon = Number(r.lon);
                    const lat = Number(r.lat);
                    if (Number.isNaN(lon) || Number.isNaN(lat)) continue;

                    const f = new ol.Feature({
                        geometry: new ol.geom.Point(ol.proj.fromLonLat([lon, lat])),
                        // âœ… äº•åå­—æ®µ
                        name: r.well_name,
                        well_name: r.well_name,
                        // âœ… ä½ æƒ³æ˜¾ç¤ºçš„æ•°å€¼ï¼ˆè¿™é‡Œç”¨åœ°å±‚åšåº¦ï¼‰
                        value: r.stratum_thickness,
                        stratum: r.stratum_name
                    });
                    pointFeatures.push(f);
                }
                console.log('âœ… äº•ç‚¹è¦ç´ æ„å»ºæˆåŠŸ:', pointFeatures.length);
            } else {
                console.warn('âš ï¸ dataRows ä¸ºç©ºï¼šä¸ä¼šæ˜¾ç¤ºäº•ç‚¹');
            }

            const pointSource = new ol.source.Vector({ features: pointFeatures });

            // âœ… 7) é¢å›¾å±‚ï¼ˆç­‰å€¼çº¿é¢ï¼‰ï¼Œä½¿ç”¨åç«¯ properties.fill æ¸²æŸ“
            const polygonLayer = new ol.layer.Vector({
                source: polygonSource,
                zIndex: 10,
                style: function(feature) {
                    // åç«¯è¿”å›çš„æ˜¯ fillï¼ˆä½ è´´å‡ºæ¥çš„å°±æ˜¯ properties.fillï¼‰
                    const fillHex = feature.get('fill') || feature.get('color') || '#ff0000';
                    const v = feature.get('value');

                    const label = (v === null || v === undefined || Number.isNaN(Number(v)))
                        ? ''
                        : Number(v).toFixed(2);

                    return new ol.style.Style({
                        fill: new ol.style.Fill({
                            // âœ… å»ºè®® 0.2~0.35ï¼Œä¸è¦ 1ï¼ˆä¼šé®æŒ¡ç‚¹/åº•å›¾ï¼‰
                            color: hexToRgba(fillHex, 0.8)
                        }),
                        stroke: new ol.style.Stroke({
                            color: fillHex,
                            width: 2
                        }),
                        // é¢æ ‡ç­¾ï¼šä¸æƒ³è¦å¯æŠŠ text è¿™æ®µåˆ æ‰
                        // text: new ol.style.Text({
                        //     text: label,
                        //     font: '12px Arial',
                        //     fill: new ol.style.Fill({ color: '#000' }),
                        //     stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                        // })
                    });
                }
            });

            // âœ… 8) ç‚¹å›¾å±‚ï¼ˆäº•ç‚¹ + äº•åï¼‰ï¼Œæ°¸è¿œç›–åœ¨é¢ä¹‹ä¸Š
            const pointLayer = new ol.layer.Vector({
                source: pointSource,
                zIndex: 20,
                style: function(feature) {
                    const wellName = feature.get('well_name') || feature.get('name') || '';
                    const v = feature.get('value');
                    const vText = (v === null || v === undefined || Number.isNaN(Number(v))) ? '' : Number(v).toFixed(2);

                    // ä½ å¯ä»¥åªæ˜¾ç¤ºäº•åï¼šconst label = wellName;
                    const label = wellName ? (vText ? `${wellName}  ${vText}` : `${wellName}`) : (vText ? vText : '');

                    return new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: 4,
                            fill: new ol.style.Fill({ color: '#ff0000' }),
                            stroke: new ol.style.Stroke({ color: '#ffffff', width: 1 })
                        }),
                        text: new ol.style.Text({
                            text: label,
                            font: '12px Arial',
                            fill: new ol.style.Fill({ color: '#000' }),
                            stroke: new ol.style.Stroke({ color: '#fff', width: 3 }),
                            offsetY: -12
                        })
                    });
                }
            });

            // âœ… 9) æ·»åŠ å›¾å±‚ï¼ˆå…ˆé¢åç‚¹ï¼‰
            map.addLayer(polygonLayer);
            map.addLayer(pointLayer);

            // âœ… 10) è§†å›¾ fitï¼šç”¨â€œé¢+ç‚¹â€çš„è”åˆèŒƒå›´ï¼ˆæ›´ç¨³ï¼‰
            const extentPoly = polygonSource.getExtent();
            const extentPoint = pointSource.getExtent();

            let extent = extentPoly;
            if (!ol.extent.isEmpty(extentPoint)) {
                extent = ol.extent.extend(extent, extentPoint);
            }

            if (ol.extent.isEmpty(extent)) {
                console.warn('âš ï¸ æ•°æ®èŒƒå›´ä¸ºç©ºï¼Œæ— æ³•fitï¼›ä¿æŒå½“å‰è§†å›¾');
            } else {
                console.log('ğŸ“ æ•°æ®èŒƒå›´:', extent);
                map.getView().fit(extent, {
                    padding: [50, 50, 50, 50],
                    duration: 800,
                    maxZoom: 12
                });
            }

            // âœ… 11) éšè—è¦†ç›–å±‚
            const overlay = document.getElementById('mapOverlay');
            if (overlay) overlay.style.display = 'none';

            console.log('âœ… GeoJSONé¢ + äº•ç‚¹ å·²æˆåŠŸæ˜¾ç¤ºåœ¨åœ°å›¾ä¸Š');
            return true;

        } catch (error) {
            console.error('âŒ GeoJSONæ¸²æŸ“å¤±è´¥:', error);
            console.error('é”™è¯¯è¯¦æƒ…:', error.message, error.stack);
            return false;
        }
    }

    // æ˜¾ç¤ºå›¾åƒåœ¨åœ°å›¾ä¸Šï¼ˆè¦†ç›–æ–¹å¼ï¼‰
    function displayImageOnMap(base64Str) {
        if (!map) return;

        // æ¸…é™¤ç°æœ‰å›¾å±‚ï¼ˆä¿ç•™ç“¦ç‰‡å›¾å±‚ï¼‰
        const layers = map.getLayers().getArray();
        const tileLayer = layers[0]; // ç“¦ç‰‡å›¾å±‚æ˜¯ç¬¬ä¸€ä¸ª

        // ç§»é™¤å…¶ä»–å›¾å±‚
        for (let i = layers.length - 1; i > 0; i--) {
            map.removeLayer(layers[i]);
        }

        // åˆ›å»ºå›¾åƒè¦†ç›–
        // const imageLayer = new ol.layer.Image({
        //     source: new ol.source.ImageStatic({
        //         url: `data:image/png;base64,${base64Str}`,
        //         imageExtent: [103.0, 28.0, 107.0, 32.0], // å››å·ç›†åœ°å¤§è‡´èŒƒå›´
        //         projection: 'EPSG:4326'
        //     }),
        //     opacity: 0.8
        // });

        // map.addLayer(imageLayer);

        // è°ƒæ•´è§†å›¾
        map.getView().fit([103.0, 28.0, 107.0, 32.0], {
            padding: [20, 20, 20, 20],
            duration: 500
        });

        // éšè—è¦†ç›–å±‚
        const overlay = document.getElementById('mapOverlay');
        if (overlay) {
            overlay.style.display = 'none';
        }

        console.log('âœ… å›¾åƒå·²æ˜¾ç¤ºåœ¨åœ°å›¾ä¸Š');
    }

    // æ˜¾ç¤ºæµ‹è¯•çŠ¶æ€
    function showTestStatus(message, type = 'loading') {
        const statusEl = document.getElementById('testStatus');
        statusEl.textContent = message;
        statusEl.className = 'test-status ' + type;
        statusEl.style.display = 'block';

        // 3ç§’åè‡ªåŠ¨éšè—
        setTimeout(() => {
            statusEl.style.display = 'none';
        }, 3000);
    }

    // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©ç•Œé¢
    function addMessage(role, text, type = 'text', imageSrc = null) {
        const chatMessages = document.getElementById('chatMessages');
        const msgDiv = document.createElement('div');
        msgDiv.className = `msg ${role}`;

        let content = '';
        if (type === 'image' && imageSrc) {
            let imgBase64 = imageSrc;
            if (typeof imageSrc === 'object') {
                const keys = Object.keys(imageSrc);
                if (keys.length > 0) {
                    imgBase64 = imageSrc[keys[0]];
                }
            }
            content = `<span class="role-label">${role === 'user' ? 'ğŸ§‘' : 'ğŸ¤–'}</span>
                           <div class="chat-image">
                               <img src="data:image/png;base64,${imgBase64}" 
                                    style="max-width:200px; max-height:150px; border-radius:4px; cursor:pointer;"
                                    onclick="previewImage('${imgBase64}')">
                           </div>`;

            // åŒæ—¶åœ¨å³ä¾§åœ°å›¾åŒºåŸŸæ˜¾ç¤ºå¤§å›¾
            // displayMapInRightPanel(imgBase64);
        } else {
            content = `<span class="role-label">${role === 'user' ? 'ğŸ§‘' : 'ğŸ¤–'}</span>
                           <div class="text">${text}</div>`;
        }

        msgDiv.innerHTML = content;
        chatMessages.appendChild(msgDiv);

        // æ»šåŠ¨åˆ°åº•éƒ¨
        const chatBox = document.querySelector('.chat-box');
        if (chatBox) {
            chatBox.scrollTop = chatBox.scrollHeight;
        }
    }

    // åœ¨å³ä¾§åœ°å›¾åŒºåŸŸæ˜¾ç¤ºå›¾åƒ
    function displayMapInRightPanel(base64Str) {
        const mapContainer = document.getElementById('mapContainer');

        // æ¸…é™¤ç°æœ‰å†…å®¹ï¼ˆä¿ç•™ä¸‹è½½æŒ‰é’®å’Œå›¾ä¾‹ï¼‰
        const existingImg = mapContainer.querySelector('.map-display-image');
        if (existingImg) {
            existingImg.remove();
        }

        // åˆ›å»ºå›¾åƒå…ƒç´ 
        const img = document.createElement('img');
        img.src = `data:image/png;base64,${base64Str}`;
        img.className = 'map-display-image';
        img.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                max-width: 90%;
                max-height: 90%;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                cursor: pointer;
                z-index: 10;
            `;
        img.onclick = () => previewImage(base64Str);

        mapContainer.appendChild(img);
    }

    // æ›´æ–°å›¾ä¾‹
    function updateLegend(geojson) {
        const legendCard = document.getElementById('legendCard');
        const legendContent = document.getElementById('legendContent');

        if (!legendCard || !legendContent) {
            console.warn('âš ï¸ æ‰¾ä¸åˆ° legendCard æˆ– legendContent');
            return;
        }

        // å…¼å®¹ {map:{...}} åŒ…è£…
        if (geojson && !geojson.type && geojson.map && geojson.map.type) {
            geojson = geojson.map;
        }

        // å…¼å®¹å­—ç¬¦ä¸²
        if (typeof geojson === 'string') {
            try {
                geojson = JSON.parse(geojson);
            } catch (e) {
                console.warn('âš ï¸ å›¾ä¾‹è§£æGeoJSONå­—ç¬¦ä¸²å¤±è´¥');
                legendCard.style.display = 'none';
                return;
            }
        }

        // åŸºæœ¬æ ¡éªŒ
        if (!geojson || !Array.isArray(geojson.features) || geojson.features.length === 0) {
            legendCard.style.display = 'none';
            return;
        }

        // ä» features æ”¶é›† (value, fill)ï¼Œåªå¯¹ Polygon/MultiPolygon ç”Ÿæˆå›¾ä¾‹
        const raw = [];
        for (const f of geojson.features) {
            const gType = f?.geometry?.type;
            const isPolygon = (gType === 'Polygon' || gType === 'MultiPolygon');
            if (!isPolygon) continue;

            const p = f?.properties || {};
            const value = p.value;
            const fill = p.fill || p.color;

            if (value === null || value === undefined) continue;
            if (!fill) continue;

            const vNum = Number(value);
            if (Number.isNaN(vNum)) continue;

            raw.push({ value: vNum, fill: String(fill) });
        }

        if (raw.length === 0) {
            console.warn('âš ï¸ features ä¸­æ²¡æœ‰å¯ç”¨äºå›¾ä¾‹çš„ (value, fill)');
            legendCard.style.display = 'none';
            return;
        }

        // å»é‡ï¼ˆåŒè‰²åŒå€¼åˆå¹¶ï¼‰ï¼Œå¹¶æŒ‰ value æ’åº
        const uniqMap = new Map();
        for (const it of raw) {
            const key = `${it.fill}|${it.value.toFixed(6)}`;
            if (!uniqMap.has(key)) uniqMap.set(key, it);
        }
        const uniq = Array.from(uniqMap.values()).sort((a, b) => b.value - a.value);

        // ç”Ÿæˆ HTMLï¼ˆinline style å¼ºåˆ¶è‰²å—å¯è§ï¼‰
        legendContent.innerHTML = uniq.map(it => {
            const label = Number.isFinite(it.value) ? it.value.toFixed(2) : String(it.value);
            const color = it.fill;

            return `
          <div style="display:flex; align-items:center; gap:8px; margin:6px 0;">
            <span style="
              display:inline-block;
              width:14px;
              height:14px;
              border-radius:3px;
              border:1px solid rgba(0,0,0,0.25);
              background:${color};
              flex:0 0 auto;
            "></span>
            <span style="font-size:12px; line-height:14px;">${label}</span>
          </div>
        `;
        }).join('');

        // æ˜¾ç¤ºå›¾ä¾‹å¡ç‰‡
        legendCard.style.display = 'block';
    }


    // æ›´æ–°å†å²åˆ—è¡¨
    function updateHistoryList(history) {
        const historyListEl = document.getElementById('historyList');
        historyListEl.innerHTML = '';

        history.forEach((item, index) => {
            const li = document.createElement('li');
            li.style.cssText = 'margin-bottom: 8px; padding: 6px 8px; border-radius: 8px; cursor: pointer; transition: background 0.2s;';
            li.innerHTML = `
                    <div style="font-size: 10px; color: #666;">${item.timestamp || 'æœªçŸ¥æ—¶é—´'}</div>
                    <div style="font-size: 11px; color: #333;">${item.text || 'æ— æè¿°'}</div>
                `;
            li.onclick = () => {
                document.getElementById('userInput').value = item.text;
                toggleHistory();
            };
            li.onmouseover = () => li.style.background = '#f5f5f5';
            li.onmouseout = () => li.style.background = 'transparent';
            historyListEl.appendChild(li);
        });

        historyList = history;
    }

    // åˆ‡æ¢å†å²é¢æ¿
    function toggleHistory() {
        showHistory = !showHistory;
        const historyPanel = document.querySelector('.history-panel');
        if (historyPanel) {
            historyPanel.style.display = showHistory ? 'block' : 'none';
        }

        // å¦‚æœæ‰“å¼€å†å²é¢æ¿ï¼Œè·å–å†å²è®°å½•
        if (showHistory) {
            getHistory();
        }
    }

    // é¢„è§ˆå›¾åƒ
    function previewImage(base64Str) {
        const overlay = document.createElement('div');
        overlay.className = 'preview-overlay';
        overlay.innerHTML = `<img src="data:image/png;base64,${base64Str}" class="preview-img">`;
        overlay.onclick = () => overlay.remove();
        document.body.appendChild(overlay);
    }

    // ä¸‹è½½åœ°å›¾
    function downloadMap() {
        if (!currentImage) {
            alert('æ²¡æœ‰å¯ä¸‹è½½çš„åœ°å›¾ï¼');
            return;
        }

        let base64Str = currentImage;
        if (typeof currentImage === 'object') {
            const keys = Object.keys(currentImage);
            if (keys.length > 0) {
                base64Str = currentImage[keys[0]];
            }
        }

        const link = document.createElement('a');
        link.href = `data:image/png;base64,${base64Str}`;
        link.download = `contour_map_${Date.now()}.png`;
        link.click();
    }

    // è·å–å†å²è®°å½•
    async function getHistory() {
        try {
            const response = await fetch(`${API_BASE}/history?limit=10`);
            const data = await response.json();

            if (response.ok) {
                const history = data.history || [];
                updateHistoryList(history);
            }
        } catch (error) {
            console.error('è·å–å†å²è®°å½•å¤±è´¥:', error);
        }
    }

    // è¯»å–CSVæ–‡ä»¶å¹¶è§£ææ•°æ®
    async function readCSVFile() {
        try {
            console.log('ğŸ”„ å¼€å§‹è¯»å–CSVæ–‡ä»¶...');
            
            // å°è¯•è¯»å–CSVæ–‡ä»¶
            const response = await fetch('../ContourAgent-backend/coal.csv');
            console.log('ğŸ“Š CSVæ–‡ä»¶å“åº”çŠ¶æ€:', response.status, response.ok);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const csvText = await response.text();
            console.log('ğŸ“Š CSVæ–‡ä»¶å¤§å°:', csvText.length, 'å­—ç¬¦');
            
            // è§£æCSVæ•°æ®
            const jsonData = parseCSV(csvText);
            
            console.log('ğŸ“Š CSVæ•°æ®è¯»å–æˆåŠŸ:', jsonData.length, 'æ¡è®°å½•');
            console.log('ğŸ“Š æ•°æ®ç¤ºä¾‹:', jsonData[0]);
            
            return jsonData;
        } catch (error) {
            console.error('âŒ è¯»å–CSVæ–‡ä»¶å¤±è´¥:', error);
            console.error('é”™è¯¯è¯¦æƒ…:', error.message, error.stack);
            return null;
        }
    }

    // è§£æCSVæ–‡æœ¬ä¸ºJSONæ•°ç»„
    function parseCSV(csvText) {
        const lines = csvText.trim().split('\n');
        if (lines.length === 0) return [];
        
        // è·å–è¡¨å¤´
        const headers = lines[0].split(',').map(h => h.trim());
        
        // è§£ææ•°æ®è¡Œ
        const data = [];
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            
            const values = line.split(',').map(v => v.trim());
            const row = {};
            
            headers.forEach((header, index) => {
                let value = values[index];
                // å°è¯•è½¬æ¢ä¸ºæ•°å­—
                if (!isNaN(value) && value !== '') {
                    value = parseFloat(value);
                }
                row[header] = value;
            });
            
            data.push(row);
        }
        
        return data;
    }

    // ç”Ÿæˆç­‰å€¼çº¿å›¾ï¼ˆç›´æ¥ä½¿ç”¨CSVæ•°æ®ï¼‰
    async function generateContourFromCSV(csvData, variable) {
        if (!csvData || csvData.length === 0) {
            throw new Error('CSVæ•°æ®ä¸ºç©º');
        }

        // å‡†å¤‡æ•°æ®æ ¼å¼
        const wellData = csvData.map(row => ({
            well_name: row.well_name,
            lon: parseFloat(row.lon),
            lat: parseFloat(row.lat),
            value: parseFloat(row[variable]) || parseFloat(row.lith_thickness) || parseFloat(row.ratio) || 0
        })).filter(item => !isNaN(item.lon) && !isNaN(item.lat) && !isNaN(item.value));

        console.log('ğŸ“Š å‡†å¤‡CSVæ•°æ®:', wellData.length, 'æ¡è®°å½•');

        // æ¨¡æ‹Ÿå…‹é‡Œé‡‘æ’å€¼å’Œç­‰å€¼çº¿ç”Ÿæˆ
        const geojson = generateMockGeoJSON(wellData, variable);
        const imageData = await generateContourImage(geojson);

        return {
            dataResult: wellData,
            geojsonResult: geojson,
            imageResult: imageData
        };
    }

    // ä¸»ç•Œé¢å‘é€æ¶ˆæ¯ï¼ˆæ ¸å¿ƒåŠŸèƒ½ - è°ƒç”¨åç«¯AgentæœåŠ¡ï¼‰
    async function sendMessage() {
        const input = document.getElementById('userInput');
        const content = input.value.trim();
        if (!content) return;

        addMessage('user', content);
        input.value = '';

        showTestStatus('ğŸ”„ Processing...', 'loading');

        try {
            const startTime = Date.now();

            // Check whether this is a CSV loading request
            if (
                content.includes('load CSV') ||
                content.includes('read CSV') ||
                content.includes('use CSV') ||
                content.includes('coal.csv')
            ) {
                const csvData = await readCSVFile();
                if (!csvData) {
                    throw new Error('Unable to read coal.csv file');
                }

                addMessage('assistant', `ğŸ“Š CSV data loaded successfully: ${csvData.length} records`);
                addMessage('assistant', `ğŸ“‹ Fields: ${Object.keys(csvData[0]).join(', ')}`);

                const preview = csvData.slice(0, 3);
                addMessage('assistant', `ğŸ” Data preview:\n${JSON.stringify(preview, null, 2)}`);

                showTestStatus('âœ… CSV data loading completed', 'loading');
                return;
            }

            // Chinese task: draw coal rock distribution map of Longtan Formation
            if (
                content.includes('ç»˜åˆ¶å››å·ç›†åœ°é¾™æ½­ç»„ç…¤å²©åˆ†å¸ƒå›¾') ||
                content.includes('å››å·ç›†åœ°é¾™æ½­ç»„ç…¤å²©')
            ) {
                addMessage('assistant', 'ğŸ”„ Executing task: coal rock distribution map of the Longtan Formation');

                addMessage('assistant', 'ğŸ“Š Step 1: Reading coal.csv data...');
                const csvData = await readCSVFile();
                if (!csvData) {
                    throw new Error('Unable to read coal.csv file');
                }
                addMessage('assistant', `âœ… CSV data loaded successfully: ${csvData.length} records`);

                addMessage('assistant', 'ğŸ“ Step 2: Calling backend API for interpolation and mapping...');

                const requestData = {
                    text: content,
                    csvData: csvData,
                    variable: 'lith_thickness'
                };

                const response = await fetch(`${API_BASE}/task`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                const duration = ((Date.now() - startTime) / 1000).toFixed(2);

                if (result.dataResult && result.dataResult.length > 0) {
                    addMessage('assistant', `ğŸ“Š Data processing completed: ${result.dataResult.length} well points`);
                }

                if (result.krigingResult) {
                    // addMessage('assistant', 'ğŸ“ Interpolation completed');
                }

                if (result.imageResult) {
                    addMessage(
                        'assistant',
                        'âœ… Coal rock distribution map of the Longtan Formation generated',
                        'image',
                        result.imageResult
                    );
                }

                if (result.geojsonResult) {
                    const geo = result.geojsonResult?.map ?? result.geojsonResult;

                    addMessage('assistant', 'ğŸ—ºï¸ Contour vector data loaded to map');
                    updateLegend(geo);

                    try {
                        displayGeoJSONOnMap(geo);
                    } catch (e) {
                        console.warn('GeoJSON rendering failed:', e);
                        if (result.imageResult) {
                            displayImageOnMap(result.imageResult);
                        }
                    }
                }

                showTestStatus(`âœ… Map generation completed (${duration}s)`, 'loading');
                return;
            }

            // English mapping request
            if (
                content.includes('Generate the coal rock distribution map') ||
                content.includes('Longtan Formation') ||
                content.includes('Sichuan Basin') ||
                content.includes('Ordinary Kriging') ||
                content.includes('spherical model')
            ) {
                const csvData = await readCSVFile();
                if (!csvData) {
                    throw new Error('Unable to read coal.csv file');
                }

                const requestData = {
                    text: content,
                    csvData: csvData,
                    variable: 'lith_thickness'
                };

                const response = await fetch(`${API_BASE}/task`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                const duration = ((Date.now() - startTime) / 1000).toFixed(2);

                if (result.dataResult && result.dataResult.length > 0) {
                    addMessage('assistant', `ğŸ“Š Data processing completed: ${result.dataResult.length} well points`);
                }

                if (result.krigingResult) {
                    // addMessage('assistant', 'ğŸ“ Interpolation completed');
                }

                if (result.imageResult) {
                    addMessage(
                        'assistant',
                        'âœ… Coal rock distribution map of the Longtan Formation generated',
                        'image',
                        result.imageResult
                    );
                    currentImage = result.imageResult;
                    displayMapInRightPanel(result.imageResult);
                }

                if (result.geojsonResult) {
                    addMessage('assistant', 'ğŸ—ºï¸ Contour vector data loaded to map');
                    updateLegend(result.geojsonResult);

                    try {
                        const geo = result.geojsonResult?.map ?? result.geojsonResult;
                        const rows = result.dataResult?.rows ?? [];
                        displayGeoJSONOnMap(geo, rows);
                        console.log('GeoJSON vector data rendered to map');
                    } catch (e) {
                        console.warn('GeoJSON rendering failed:', e);
                        if (result.imageResult) {
                            displayImageOnMap(result.imageResult);
                        }
                    }
                }

                showTestStatus(`âœ… Map generation completed (${duration}s)`, 'loading');
                return;
            }

            // Generic backend Agent call
            addMessage('assistant', `ğŸ”„ Calling backend Agent service for: "${content}"`);

            const response = await fetch(`${API_BASE}/task`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: content })
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const result = await response.json();
            const duration = ((Date.now() - startTime) / 1000).toFixed(2);

            if (result.nlpResult) {
                // addMessage('assistant', `ğŸ“ Parsed intent:\n${JSON.stringify(result.nlpResult, null, 2)}`);
            }

            if (result.plan) {
                // addMessage('assistant', `ğŸ“‹ Execution plan: ${result.plan.pipeline.join(' â†’ ')}`);
            }

            if (result.dataResult && result.dataResult.length > 0) {
                // addMessage('assistant', `ğŸ“Š Data loaded: ${result.dataResult.length} well points`);
            }

            if (result.krigingResult) {
                // addMessage('assistant', 'ğŸ“ Interpolation completed');
            }

            if (result.imageResult) {
                addMessage('assistant', 'âœ… Contour map generated', 'image', result.imageResult);
                currentImage = result.imageResult;
                displayMapInRightPanel(result.imageResult);
            }

            if (result.geojsonResult) {
                addMessage('assistant', 'ğŸ—ºï¸ Contour vector data loaded to map');
                updateLegend(result.geojsonResult);

                try {
                    const geo = result.geojsonResult?.map ?? result.geojsonResult;
                    const rows = result.dataResult?.rows ?? [];
                    displayGeoJSONOnMap(geo, rows);
                } catch (e) {
                    console.warn('GeoJSON rendering failed:', e);
                    if (result.imageResult) {
                        addMessage('assistant', 'âš ï¸ Vector rendering failed, showing image instead');
                        displayImageOnMap(result.imageResult);
                    }
                }
            }

            if (result.feedbackParsed) {
                addMessage('assistant', `ğŸ”„ Parsed feedback:\n${JSON.stringify(result.feedbackParsed, null, 2)}`);
            }

            showTestStatus(`âœ… All tasks completed (${duration}s)`, 'loading');

        } catch (err) {
            showTestStatus(`âŒ Error: ${err.message}`, 'error');
            addMessage(
                'assistant',
                `âŒ Error: ${err.message}\n\nPlease ensure:\n1. Backend service is running (cd ../ContourAgent-backend && python api.py)\n2. Service is available at http://127.0.0.1:8000`
            );
            console.error('Detailed error:', err);
        }
    }

    // æ–‡ä»¶ä¸Šä¼ å¤„ç†
    async function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        addMessage('assistant', 'ğŸ“Š æ–‡ä»¶ä¸Šä¼ ä¸­...');
        showTestStatus('æ–‡ä»¶ä¸Šä¼ ä¸­...', 'loading');

        const reader = new FileReader();
        reader.onload = async (e) => {
            // ç®€åŒ–å¤„ç†ï¼Œå®é™…åº”ä½¿ç”¨xlsxåº“è§£æ
            const testData = [
                { well_name: 'æµ‹è¯•äº•1', lon: 104.5, lat: 30.2, thickness: 100 },
                { well_name: 'æµ‹è¯•äº•2', lon: 105.0, lat: 30.5, thickness: 150 },
                { well_name: 'æµ‹è¯•äº•3', lon: 105.5, lat: 30.8, thickness: 200 }
            ];

            try {
                const res = await fetch(`${API_BASE}/upload-excel`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ data: testData })
                });

                const data = await res.json();
                if (res.ok) {
                    showTestStatus('âœ… Excelæ•°æ®å¤„ç†å®Œæˆ', 'loading');
                    addMessage('assistant', 'âœ… Excelæ•°æ®å¤„ç†å®Œæˆ');

                    if (data.imageResult) {
                        addMessage('assistant', 'âœ… ç­‰å€¼çº¿å›¾å·²ç”Ÿæˆ', 'image', data.imageResult);
                        currentImage = data.imageResult;
                    }
                } else {
                    showTestStatus(`âŒ æ–‡ä»¶å¤„ç†å¤±è´¥: ${data.error || 'Unknown error'}`, 'error');
                    addMessage('assistant', 'âŒ æ–‡ä»¶å¤„ç†å¤±è´¥: ' + (data.error || 'Unknown error'));
                }
            } catch (err) {
                showTestStatus(`âŒ æ–‡ä»¶ä¸Šä¼ å¤±è´¥: ${err.message}`, 'error');
                addMessage('assistant', 'âŒ æ–‡ä»¶ä¸Šä¼ å¤±è´¥: ' + err.message);
            }
        };
        reader.readAsArrayBuffer(file);
    }

    // é”®ç›˜å¿«æ·é”®
    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'Enter') {
            sendMessage();
        }
    });

    // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥APIè¿æ¥å’Œåˆå§‹åŒ–åœ°å›¾
    window.addEventListener('load', async function() {
        // æ£€æŸ¥æ˜¯å¦é€šè¿‡HTTPåè®®è®¿é—®ï¼ˆé¿å…file://çš„CORSé—®é¢˜ï¼‰
        if (window.location.protocol === 'file:') {
            showTestStatus('âš ï¸ è¯·é€šè¿‡HTTPæœåŠ¡å™¨è®¿é—®æ­¤æ–‡ä»¶ï¼Œé¿å…CORSé—®é¢˜', 'error');
            addMessage('assistant', 'âš ï¸ é‡è¦æç¤ºï¼šè¯·é€šè¿‡HTTPæœåŠ¡å™¨è®¿é—®æ­¤æ–‡ä»¶ï¼Œä¾‹å¦‚ä½¿ç”¨VS Codeçš„Live Serveræ’ä»¶ï¼Œæˆ–è¿è¡Œï¼špython -m http.server 8080');
            return;
        }

        // åˆå§‹åŒ–OpenLayersåœ°å›¾
        try {
            initOfflineMap();
        } catch (error) {
            console.warn('åœ°å›¾åˆå§‹åŒ–å¤±è´¥:', error);
        }

        try {
            const response = await fetch(`${API_BASE}/history?limit=1`, {
                method: 'GET',
                signal: AbortSignal.timeout(5000)
            });
            console.log('âœ… API connection successful:', response.status);
            showTestStatus('âœ… API connection successful', 'loading');
        } catch (error) {
            console.warn('âš ï¸ API connection failed:', error.message);
            showTestStatus('âš ï¸ API connection failed. Please check the backend service.', 'error');
            addMessage(
                'assistant',
                'âŒ Unable to connect to the backend service. Please ensure:\n' +
                '1. The backend service is running (python api.py)\n' +
                '2. The service is available at http://127.0.0.1:8000\n' +
                '3. This page is accessed via HTTP protocol (not file://)'
            );
        }

    });
</script>
</body>
</html>
